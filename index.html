<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><title>任春晓的博客 - 学而不思则罔，思而不学则殆</title><meta name="description" content="Java，JVM，Redis，Hbase，分布式，Mongo"><link type="text/css" rel="stylesheet" href="/css/pure.css?v=0.0.1"><link type="text/css" rel="stylesheet" href="/css/style.css?v=0.0.1"><script type="text/javascript" src="//cdn.bootcss.com/jquery/1.11.0/jquery.min.js"></script></head></html><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">任春晓的博客</h1><a id="logo" href="/.">任春晓的博客</a></div><div id="nav-menu"><div class="bitcron_nav"><div class="site_nav_wrap"><div class="site_nav"><span class="a_container"><a href="/." class="selected active current">首页</a></span><span class="a_container"><a href="/archives/">归档</a></span><span class="a_container"><a href="/about/">关于</a></span><span class="a_container"><a href="/atom.xml">订阅</a></span></div></div></div></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2017/11/11/timestamp/">深入理解程序中的时间属性</a></h2><div class="post-meta">2017-11-11</div><div class="post-content"><p>最近在开发的时候遇到了一些跟时间相关的坑，这篇文章主要记录一下通过遇到的坑对时间属性的理解。</p></div></div><div class="post"><h2 class="post-title"><a href="/2017/11/08/cms-gc/">深入学习 CMS GC</a></h2><div class="post-meta">2017-11-08</div><div class="post-content"><p>本文是对 「A Generational Mostly-concurrent Garbage Collector」论文的学习笔记。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/10/09/linkedlist-algorithm1/">LinkedList 简单算法题解析</a></h2><div class="post-meta">2016-10-09</div><div class="post-content"><h2 id="LinkedList-算法题大纲"><a href="#LinkedList-算法题大纲" class="headerlink" title="LinkedList 算法题大纲"></a>LinkedList 算法题大纲</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2016/09/28/java-thread-safe/">java 线程安全性</a></h2><div class="post-meta">2016-09-28</div><div class="post-content"><p>并发编程中，由于不恰当的执行顺序出现不正确的运行结果，这样的情况叫：竞态条件。最常见的的例子就是，先检查在执行(单例模式的实现)。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/09/21/java-stack/">java 实现 stack</a></h2><div class="post-meta">2016-09-21</div><div class="post-content"><p>栈是限制插入和删除只能在一个位置上进行的 List，该位置是 List 的末端，叫做栈的顶(top)，对于栈的基本操作有 push 和 pop，前者是插入，后者是删除。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/09/09/javaio-tips/">Java IO 概念理清</a></h2><div class="post-meta">2016-09-09</div><div class="post-content"><h2 id="UNIX-当中的5种-I-O-模型"><a href="#UNIX-当中的5种-I-O-模型" class="headerlink" title="UNIX 当中的5种 I/O 模型"></a>UNIX 当中的5种 I/O 模型</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2016/09/09/java-list-iterator/">jdk 中的 List 的迭代方式</a></h2><div class="post-meta">2016-09-09</div><div class="post-content"><p>首先看段代码：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/08/16/tree-inTraverse/">二叉树的中序遍历</a></h2><div class="post-meta">2016-08-16</div><div class="post-content"><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。在遍历左、右子树时，仍然先遍历左子树，再访问根结点，最后遍历右子树。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/08/15/tree-PreTraverse/">二叉树的先序遍历</a></h2><div class="post-meta">2016-08-15</div><div class="post-content"><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>基本定义简单如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/07/29/elasticsearch-mapping/">Elasticsearch Mapping 学习</a></h2><div class="post-meta">2016-07-29</div><div class="post-content"><h3 id="Mapping-Types"><a href="#Mapping-Types" class="headerlink" title="Mapping Types"></a>Mapping Types</h3><p>每一个 mapping type 都有：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/07/27/scalableio/">Scalable IO in Java</a></h2><div class="post-meta">2016-07-27</div><div class="post-content"><p>网络框架基本上会有如下几个基本结构：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/07/21/tcpwindow/">TCP 滑动窗口</a></h2><div class="post-meta">2016-07-21</div><div class="post-content"><p>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/07/20/tcpstatus/">TCP 状态转移以及一些概念</a></h2><div class="post-meta">2016-07-20</div><div class="post-content"><p>在 TCP／IP 协议当中，我们创建连接与终止连接的时候会涉及到内部状态的转换，其中有个全图很乱看不懂，就用下面简化的图来部分学习下内部状态的转换过程。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/07/18/tcphead/">TCP 部首的简单学习</a></h2><div class="post-meta">2016-07-18</div><div class="post-content"><h2 id="TCP-的部首"><a href="#TCP-的部首" class="headerlink" title="TCP 的部首"></a>TCP 的部首</h2><p><img src="https://renchunxiao.com/public/images/tcp-head.png" alt=""></p></div></div><div class="post"><h2 class="post-title"><a href="/2016/04/25/javanio-channel3/">Java NIO 之 Channel 下</a></h2><div class="post-meta">2016-04-25</div><div class="post-content"><h2 id="Socket-Channel"><a href="#Socket-Channel" class="headerlink" title="Socket Channel"></a>Socket Channel</h2><p>新的 Socket Channel 可以运行非阻塞模式，并且是可选择的。再也不用为每个 socket 创建一个线程了。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/04/18/javanio-channel2/">Java NIO 之 Channel 中</a></h2><div class="post-meta">2016-04-18</div><div class="post-content"><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p><img src="https://renchunxiao.com/public/images/nio-buffer10.png" alt=""></p></div></div><div class="post"><h2 class="post-title"><a href="/2016/04/14/javanio-channel1/">Java NIO 之 Channel 上</a></h2><div class="post-meta">2016-04-14</div><div class="post-content"><p>首先来看一些 Channel 的基础定义：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/04/11/javanio-buffer/">Java NIO 之缓冲区</a></h2><div class="post-meta">2016-04-11</div><div class="post-content"><p>一个 Buffer 对象是固定数量的数据的容器。通道是 I/O 传输发生时通过的入口,而缓冲区是这些数据传输的来源或目标。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/04/06/websocket/">入门 websocket</a></h2><div class="post-meta">2016-04-06</div><div class="post-content"><p>websocket 的概念如下链接：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/15/mybatis10/">mybatis 源码分析之 ObjectFactory 等</a></h2><div class="post-meta">2016-03-15</div><div class="post-content"><p>在 config.xml 当中有一个节点是 ObjectFactory 和 ObjectWrapperFactory:</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/09/mybatis9/">mybatis 源码分析之 TokenHandler 等</a></h2><div class="post-meta">2016-03-09</div><div class="post-content"><p>在上一篇文章当中，SqlSourceBuilder 当中有一步骤是通过 ParameterMappingTokenHandler 和 GenericTokenParser 来替换动态传入的参数，首先来分析 GenericTokenParser 的内容，GenericTokenParser 在判断是否是动态 sql 的时候也已经使用过了：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/09/enumset/">EnumSet 源码简单分析</a></h2><div class="post-meta">2016-03-09</div><div class="post-content"><p>EnumSet 的内部基本使用如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/08/mybatis8/">mybatis 源码分析之 SqlSource</a></h2><div class="post-meta">2016-03-08</div><div class="post-content"><p>在 XMLStatementBuilder 当中解析的时候，通过 LanguageDriver 创建了 SqlSource，这篇来分析 SqlSource 以及和它相关的一些类：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/07/mybatis7/">mybatis 源码分析之 SqlNode</a></h2><div class="post-meta">2016-03-07</div><div class="post-content"><p>在 XMLStatementBuilder 当中解析的时候，有一步是获取 SqlSource，内部使用的是 XMLScriptBuilder 来获取。这篇主要来分析跟 SqlSource 有关的几个类。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/03/03/mybatis6/">mybatis 源码分析之 XMLStatementBuilder</a></h2><div class="post-meta">2016-03-03</div><div class="post-content"><h2 id="XMLStatementBuilder-parseStatementNode-第四步"><a href="#XMLStatementBuilder-parseStatementNode-第四步" class="headerlink" title="XMLStatementBuilder.parseStatementNode 第四步"></a>XMLStatementBuilder.parseStatementNode 第四步</h2><p>第四步就一句话，但是里面的内容很多，我们慢慢分析：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/29/mybatis5/">mybatis 源码分析之 sql 解析</a></h2><div class="post-meta">2016-02-29</div><div class="post-content"><p>XMLMapperBuilder 当中对 sql 元素的解析：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/27/mybatis4/">mybatis 源码分析之 ResultMap</a></h2><div class="post-meta">2016-02-27</div><div class="post-content"><p>上一篇文章已经分析了解析 constructor 节点的方法，其他的节点最后基本上都是生成了 ResultMapping，discriminator 的解析就不分析了，这个 discriminator 节点主要是结果值来决定使用哪个结果映射。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/25/mybatis3/">mybatis 源码分析之 XMLMapperBuilder</a></h2><div class="post-meta">2016-02-25</div><div class="post-content"><p>在上一篇 XMLConfigBuilder 类当中，在解析 mappers 的节点还没有分析，这篇主要分析。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/24/mybatis2/">mybatis 源码分析之 BaseBuilder</a></h2><div class="post-meta">2016-02-24</div><div class="post-content"><h2 id="解析-typeAliases"><a href="#解析-typeAliases" class="headerlink" title="解析 typeAliases"></a>解析 typeAliases</h2><p>在 XMLConfigBuilder 当中的 parseConfiguration 方法当中 typeAliasesElement(root.evalNode(“typeAliases”)); 来解析 typeAliases，下面是详细代码：</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/23/new-add-redis-design/">使用 redis 实现新加入用户列表</a></h2><div class="post-meta">2016-02-23</div><div class="post-content"><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>一个平台每天都有新用户加入，当有新的用户加入的时候，在首页上会显示新加入的用户的个数，点击进去会显示这些用户的列表。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/02/23/mybatis1/">mybatis 源码分析之 Configuration</a></h2><div class="post-meta">2016-02-23</div><div class="post-content"><p>mybatis 是 java 语言的 orm 框架，<a href="http://www.mybatis.org/mybatis-3/zh/getting-started.html" target="_blank" rel="noopener">使用教程</a>。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/01/13/andriod-fragment/">Android 学习之 Fragment</a></h2><div class="post-meta">2016-01-13</div><div class="post-content"><h2 id="Fragment-是什么"><a href="#Fragment-是什么" class="headerlink" title="Fragment 是什么"></a>Fragment 是什么</h2><p>碎片(Fragment)是一种可以嵌入在活动(activity)当中的 UI 片段。</p></div></div><div class="post"><h2 class="post-title"><a href="/2016/01/12/docker1/">docker 入门学习一</a></h2><div class="post-meta">2016-01-12</div><div class="post-content"><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2016/01/07/andriod-activity/">Android 学习之 Activity</a></h2><div class="post-meta">2016-01-07</div><div class="post-content"><p>活动(Activity)是最容易吸引到用户的地方了,它是一种可以包含用户界面的组件, 主要用于和用户进行交互。一个应用程序中可以包含零个或多个活动。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/28/Elasticsearch3/">Elasticsearch 基本查询学习</a></h2><div class="post-meta">2015-12-28</div><div class="post-content"><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p>在 Elasticsearch 当中最简单的查询是使用 URI 请求查询，例如下面的查询：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/28/code-refactor2/">重构之可度量的代码异味</a></h2><div class="post-meta">2015-12-28</div><div class="post-content"><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>创建一个好的声明模型是软件开发的一大挑战，一般使用如下工具：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/24/code-refactor1/">重构之可度量的代码异味</a></h2><div class="post-meta">2015-12-24</div><div class="post-content"><h2 id="可度量的代码异味"><a href="#可度量的代码异味" class="headerlink" title="可度量的代码异味"></a>可度量的代码异味</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/23/Elasticsearch2/">Elasticsearch 索引学习</a></h2><div class="post-meta">2015-12-23</div><div class="post-content"><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>创建索引的时候指定分片的个数：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/17/Elasticsearch1/">Elasticsearch 初入门</a></h2><div class="post-meta">2015-12-17</div><div class="post-content"><p>Elasticsearch 与关系型数据库的对比：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/15/java8-localdate/">Java8 新的日期和时间 API</a></h2><div class="post-meta">2015-12-15</div><div class="post-content"><h2 id="时间线"><a href="#时间线" class="headerlink" title="时间线"></a>时间线</h2><p>在 Java 当中，一个 Instant 对象表示时间轴上的一个点。并且我们可以计算两个时间点之间的时间量。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/14/java8-stream2/">Java8 stream 学习3</a></h2><div class="post-meta">2015-12-14</div><div class="post-content"><h2 id="将结果收集到-Map-中"><a href="#将结果收集到-Map-中" class="headerlink" title="将结果收集到 Map 中"></a>将结果收集到 Map 中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getResultToMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Stream&lt;String&gt; stream = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>);</span><br><span class="line">		Map&lt;String, Integer&gt; map = stream.collect(Collectors</span><br><span class="line">				.toMap(String::toString, String::length));</span><br><span class="line">		System.out.println(map);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/09/java8-stream1/">Java8 stream 学习2</a></h2><div class="post-meta">2015-12-09</div><div class="post-content"><h2 id="聚合方法"><a href="#聚合方法" class="headerlink" title="聚合方法"></a>聚合方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">streamJuHe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> count = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>).count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">		Optional&lt;String&gt; max = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>).max(</span><br><span class="line">				String::compareToIgnoreCase);</span><br><span class="line">		Optional&lt;String&gt; min = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>).min(</span><br><span class="line">				String::compareToIgnoreCase);</span><br><span class="line">		System.out.println(max.get());</span><br><span class="line">		System.out.println(min.get());</span><br><span class="line">		Optional&lt;String&gt; first = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>).findFirst();</span><br><span class="line">		System.out.println(first.get());</span><br><span class="line">		Optional&lt;String&gt; any = Stream.of(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"da"</span>, <span class="string">"asdass"</span>)</span><br><span class="line">				.filter(s -&gt; s.startsWith(<span class="string">"a"</span>)).findAny();<span class="comment">//匹配任何一个，可以使用 parallel 方法并行处理</span></span><br><span class="line">		System.out.println(any.get());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/2015/12/08/java8-stream/">Java8 stream 学习1</a></h2><div class="post-meta">2015-12-08</div><div class="post-content"><p>java8 当中引入的了流处理。引入流处理方便对集合进行处理，当我们想要遍历集合进行处理的时候可以使用 stram api 进行操作。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/11/19/java8-lambda2/">Java8 lambda 表达式初体验下</a></h2><div class="post-meta">2015-11-19</div><div class="post-content"><h2 id="构造器引用"><a href="#构造器引用" class="headerlink" title="构造器引用"></a>构造器引用</h2><p>构造器引用与方法引类似，不同的是构造器引用使用的方法名是 new。例如，Buttton::new。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/11/18/java8-lambda/">Java8 lambda 表达式初体验上</a></h2><div class="post-meta">2015-11-18</div><div class="post-content"><p>lambda 表达式，是一段可以传递的代码，可以被多次执行。在 java8 之前，如果我们想写一个简单的比较器 Compartor ，我们需要创建一个实现类或者一个匿名内部类类传入到需要比较的方法内当中。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/11/03/java-executor/">Java Executor 框架学习</a></h2><div class="post-meta">2015-11-03</div><div class="post-content"><p>大多数并发都是通过任务执行的方式来实现的。一般有两种方式执行任务：串行和并行。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/10/21/jvm-new-object/">Java 对象的创建与布局</a></h2><div class="post-meta">2015-10-21</div><div class="post-content"><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p>虚拟机遇到 new 指令，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用是否已经被加载、解析、初始化过。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/10/13/jvm-gc-types2/">Jvm 垃圾收集器 CMS &amp; G1</a></h2><div class="post-meta">2015-10-13</div><div class="post-content"><h2 id="CMS-Concurrent-Mark-Sweep-收集器"><a href="#CMS-Concurrent-Mark-Sweep-收集器" class="headerlink" title="CMS(Concurrent Mark Sweep) 收集器"></a>CMS(Concurrent Mark Sweep) 收集器</h2><p>CMS 收集器是获取最短回收停顿时间为目标的收集器。适用于 B/S 系统的服务端。从名字上可以看出来是使用的标记清除算法。整个清除过程如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/10/12/jvm-gc-types/">Jvm 垃圾收集器1</a></h2><div class="post-meta">2015-10-12</div><div class="post-content"><p>JVM 的垃圾回收器有很多种，先看下面的图例:</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/10/09/jvm-gc-param/">Jvm gc 常用参数记录</a></h2><div class="post-meta">2015-10-09</div><div class="post-content"><h2 id="关于JVM选项的几点："><a href="#关于JVM选项的几点：" class="headerlink" title="关于JVM选项的几点："></a>关于JVM选项的几点：</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/23/vps-use/">购买完 vps 需要做的一些事情</a></h2><div class="post-meta">2015-09-23</div><div class="post-content"><p>最近在 digitalocean 上弄了个 vps 想自己玩玩服务器的搭建过程，下面是自己记录的一些信息。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/11/jmm-final/">深入理解 Java final 变量的内存模型</a></h2><div class="post-meta">2015-09-11</div><div class="post-content"><p>对于 final 域，编译器和处理器要遵守两个重排序规则：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/09/jaxb/">JAXB 学习</a></h2><div class="post-meta">2015-09-09</div><div class="post-content"><p>JAXB（Java Architecture for XML Binding简称JAXB）允许 Java 开发人员将 Java 类映射为 XML 表示方式。JAXB 提供两种主要特性：将一个 Java 对象序列化为 XML，以及反向操作，将 XML 解析成 Java 对象。换句话说，JAXB 允许以 XML 格式存储和读取数据，而不需要程序的类结构实现特定的读取 XML 和保存 XML 的代码。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/08/jmm/">java 内存模型学习</a></h2><div class="post-meta">2015-09-08</div><div class="post-content"><h2 id="并发模型分类"><a href="#并发模型分类" class="headerlink" title="并发模型分类"></a>并发模型分类</h2><p>并发编程我们需要处理两个问题：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/06/LinkedBlockingQueue/">浅析 LinkedBlockingQueue</a></h2><div class="post-meta">2015-09-06</div><div class="post-content"><p>在 Java 并发库当中提供了，LinkedBlockingQueue，使用链表来实现的阻塞队列。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/09/02/ArrayBlockingQueue/">浅析 ArrayBlockingQueue</a></h2><div class="post-meta">2015-09-02</div><div class="post-content"><p>在 Java 并发库当中提供了，ArrayBlockingQueue，使用数组来实现的阻塞队列。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/28/tomcat-pool-PooledConnection2/">tomcat 数据库连接池之 ConnectionPool 下</a></h2><div class="post-meta">2015-08-28</div><div class="post-content"><p>上篇我们分析了，连接池应该有的基本功能，那么这次我们来分析下连接池的一些其他的功能。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/27/tomcat-pool-PooledConnection/">tomcat 数据库连接池之 ConnectionPool 上</a></h2><div class="post-meta">2015-08-27</div><div class="post-content"><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/20/lua-metatable/">lua 元表学习</a></h2><div class="post-meta">2015-08-20</div><div class="post-content"><p>Lua 中的每个值都有一个元表。table 和 userdata 可以有各自独立的原表，其他类型的值则共享其类型所属的单一元素。Lua 在创建新的 table 的时候不会创建元表。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/20/OL-PL/">理解乐观锁与悲观锁</a></h2><div class="post-meta">2015-08-20</div><div class="post-content"><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会 block 直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/20/java-queue/">java 当中的 Queue 学习</a></h2><div class="post-meta">2015-08-20</div><div class="post-content"><p>Queue 是队列的意思。队列是一种特殊的线性表，它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/19/lua-ipairs-pairs/">lua 的 pairs 和 ipairs 区别</a></h2><div class="post-meta">2015-08-19</div><div class="post-content"><p>看下文档上对 pairs 和 ipairs 的描述：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/17/java-classpath/">理解 java classpath</a></h2><div class="post-meta">2015-08-17</div><div class="post-content"><p>classpath 是一个命令行参数，或环境变量，它告诉 Java 虚拟机或者 Java 编译器到哪里寻找用户定义的类和包。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/13/java-spi-serviceloader/">java spi 深入研究以及 ClassLoader</a></h2><div class="post-meta">2015-08-13</div><div class="post-content"><p>SPI 全称为 (Service Provider Interface) ,是JDK内置的一种服务提供发现机制。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/10/guava-cache-summary/">guava cache 源码学习总结</a></h2><div class="post-meta">2015-08-10</div><div class="post-content"><h2 id="手动移除元素"><a href="#手动移除元素" class="headerlink" title="手动移除元素"></a>手动移除元素</h2><ul></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/10/http-content-encoding/">http 内容编码</a></h2><div class="post-meta">2015-08-10</div><div class="post-content"><p>HTTP 应用程序在发送之前需要对内容进行编码，如果我们返回的 HTML 内容很大，我们需要进行编码来减少传输的数据，从而提高效率。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/05/guava-cache-localcache3/">guava cache 源码学习之 CacheStats</a></h2><div class="post-meta">2015-08-05</div><div class="post-content"><h2 id="CacheStats"><a href="#CacheStats" class="headerlink" title="CacheStats"></a>CacheStats</h2><p>我们已经知道了如何创建缓存，我们也想要收集和统计缓存是如何被执行和使用的。有一个非常简单的方式获取缓存执行的信息。但是跟踪缓存操作会降低性能。如果想要收集缓存的信息，我们只需要在创建缓存的时候特殊说明 <code>recordStats()</code>。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/08/03/guava-cache-localcache2/">guava cache 源码学习之 Entry 包装</a></h2><div class="post-meta">2015-08-03</div><div class="post-content"><h2 id="基于引用的驱逐策略"><a href="#基于引用的驱逐策略" class="headerlink" title="基于引用的驱逐策略"></a>基于引用的驱逐策略</h2><p>guava cache 允许设置 weak references 为 key 和 value，也允许设置 soft references 为 value。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/31/guava-cache-localcache/">guava cache 源码学习之 LocalCache</a></h2><div class="post-meta">2015-07-31</div><div class="post-content"><h2 id="Cache-的-maxSize"><a href="#Cache-的-maxSize" class="headerlink" title="Cache 的 maxSize"></a>Cache 的 maxSize</h2><p>我们创建 cache 的时候可以指定这个 cache 可以最大装多少元素。下面就分析下，这个功能是如何实现的。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/30/guava-cache-source1/">guava cache 源码学习1</a></h2><div class="post-meta">2015-07-30</div><div class="post-content"><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在 guava wiki 当中描述了适合使用 guava cache 的一些场景：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/30/commons-logging2/">commons-logging 源码分析 2</a></h2><div class="post-meta">2015-07-30</div><div class="post-content"><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p> commons-logging 当中的 log 接口定义了一下几个日志级别：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/29/commons-logging/">commons-logging 源码分析 1</a></h2><div class="post-meta">2015-07-29</div><div class="post-content"><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>有关 java 当中的日志介绍，这里不多说，给几个链接：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/23/java-reference/">java 引用介绍</a></h2><div class="post-meta">2015-07-23</div><div class="post-content"><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference 是一个抽象类，而 SoftReference，WeakReference，PhantomReference 以及 FinalReference 都是继承它的具体类。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/22/linkedhashmap-lru/">使用 LinkedHashMap 实现 LRU 算法</a></h2><div class="post-meta">2015-07-22</div><div class="post-content"><h2 id="LinkedHashMap-源码分析"><a href="#LinkedHashMap-源码分析" class="headerlink" title="LinkedHashMap 源码分析"></a>LinkedHashMap 源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/08/maven-build/">maven 属性以及灵活构建</a></h2><div class="post-meta">2015-07-08</div><div class="post-content"><h2 id="maven-属性"><a href="#maven-属性" class="headerlink" title="maven 属性"></a>maven 属性</h2><p>一种简单的 maven 属性的使用是：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/06/java-cache1/">java 缓存学习1</a></h2><div class="post-meta">2015-07-06</div><div class="post-content"><h2 id="缓存有哪些属性"><a href="#缓存有哪些属性" class="headerlink" title="缓存有哪些属性"></a>缓存有哪些属性</h2><p>一般缓存会有如下的属性：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/07/02/maven-dependency/">maven 依赖学习</a></h2><div class="post-meta">2015-07-02</div><div class="post-content"><h2 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h2><p>依赖范围就是来控制 classpath(编译、测试、运行) 的关系，maven 的依赖范围有如下几种：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/30/jms-demo/">JMS 简单实例</a></h2><div class="post-meta">2015-06-30</div><div class="post-content"><p>使用 ActiveMQ 当做 JMS 提供者，写一个简单的 demo。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/30/maven-in-5minutes/">maven 5分钟入门</a></h2><div class="post-meta">2015-06-30</div><div class="post-content"><p>安装好 maven 后，在命令行执行如下命令：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/29/junit-runner/">junit 源码学习之 Runner</a></h2><div class="post-meta">2015-06-29</div><div class="post-content"><h2 id="Runner-作用"><a href="#Runner-作用" class="headerlink" title="Runner 作用"></a>Runner 作用</h2><p>Runner 是运行真正的单元测试的，并且会运行时候通知 RunNotifier 对象。如果要自己实现一个 Runner 的子类，需要提供一个构造方法并且包含一个 Class 参数。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/29/jms-interface/">JMS 入门学习之概念及接口</a></h2><div class="post-meta">2015-06-29</div><div class="post-content"><h2 id="JMS-概念"><a href="#JMS-概念" class="headerlink" title="JMS 概念"></a>JMS 概念</h2><p>JMS 有两种方式进行消息通信：Point-to-Point (P2P) 和 Publish/Subscriber (PUB/SUB)</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/26/junit-request/">junit 源码学习之 Request</a></h2><div class="post-meta">2015-06-26</div><div class="post-content"><h2 id="Request-作用"><a href="#Request-作用" class="headerlink" title="Request 作用"></a>Request 作用</h2><p>Request 是对将要运行的测试的抽象描述。如果我们要支持过滤和排序，我们需要一个更抽象的说明，比测试本身要更加丰富。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/25/junit-source1/">junit 框架深入学习</a></h2><div class="post-meta">2015-06-25</div><div class="post-content"><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在命令行执行 Junit</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/12/lua-table/">lua 数据结构学习</a></h2><div class="post-meta">2015-06-12</div><div class="post-content"><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>初始化一个数组，数组没有长度限制，可以根据需要增长。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/06/11/lua-string/">lua字符串学习</a></h2><div class="post-meta">2015-06-11</div><div class="post-content"><h3 id="基础字符串函数"><a href="#基础字符串函数" class="headerlink" title="基础字符串函数"></a>基础字符串函数</h3><table></div></div><div class="post"><h2 class="post-title"><a href="/2015/05/09/jvm-util/">Jvm 性能监控工具</a></h2><div class="post-meta">2015-05-09</div><div class="post-content"><p>在 java 的 bin 目录下，jdk 提供了很多使用的工具，下面学习一些监控和故障处理的工具。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/05/07/scala-learn11/">scala 层级</a></h2><div class="post-meta">2015-05-07</div><div class="post-content"><p>scala 的类层级如下图：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/05/05/scala-learn10/">scala 组合与继承</a></h2><div class="post-meta">2015-05-05</div><div class="post-content"><p>使用布局例子演示组合与继承，可以使用如下方法创建一个元素：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/27/scala-learn9/">scala 控制抽象</a></h2><div class="post-meta">2015-04-27</div><div class="post-content"><h3 id="减少代码重复"><a href="#减少代码重复" class="headerlink" title="减少代码重复"></a>减少代码重复</h3><p>我们可以使用高阶函数来简化代码重复，高阶函数是参数中包含函数的函数。看下面的例子：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/23/scala-learn8/">scala 包和引用</a></h2><div class="post-meta">2015-04-23</div><div class="post-content"><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>scala 当中的包跟 java 当中的包类似：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/21/scala-learn7/">scala 函数和闭包下</a></h2><div class="post-meta">2015-04-21</div><div class="post-content"><h3 id="偏应用函数"><a href="#偏应用函数" class="headerlink" title="偏应用函数"></a>偏应用函数</h3><p>可以使用一个下划线替换整个参数列表。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/20/scala-learn6/">scala 函数和闭包上</a></h2><div class="post-meta">2015-04-20</div><div class="post-content"><h3 id="本地函数"><a href="#本地函数" class="headerlink" title="本地函数"></a>本地函数</h3><p>在 scala 当中可以在函数中定义另外一个函数，就像本地变量一样，这种本地函数仅在包含它的代码块中可见。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/17/scala-learn5/">scala 函数式对象</a></h2><div class="post-meta">2015-04-17</div><div class="post-content"><p>通过一个 Rational 的例子来演示函数式对象，n 是分子，d 是分母。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/16/mysql-index1/">mysql 索引学习 上</a></h2><div class="post-meta">2015-04-16</div><div class="post-content"><h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><h4 id="B-TREE-索引"><a href="#B-TREE-索引" class="headerlink" title="B-TREE 索引"></a>B-TREE 索引</h4><p>如下例子：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/15/scala-learn4/">scala 内建控制结构</a></h2><div class="post-meta">2015-04-15</div><div class="post-content"><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>看如下一个例子：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/15/mysql-learn1/">mysql 一些知识点补漏</a></h2><div class="post-meta">2015-04-15</div><div class="post-content"><p>mysql 当中的 SHOW 命令：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/14/scala-learn3/">scala 基本类型和操作</a></h2><div class="post-meta">2015-04-14</div><div class="post-content"><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>类型 Byte，Short，Int，Long和 Char 被称为整数类型。整数类型加上 Float 和 Double 被称为数类型。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/14/c-learn7/">c 结构上</a></h2><div class="post-meta">2015-04-14</div><div class="post-content"><h3 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h3><p>结构是一个或多个变量的集合，这些变量可能为不同的类型。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/14/go-learn3/">go 语言包学习</a></h2><div class="post-meta">2015-04-14</div><div class="post-content"><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p>用 package 关键字定义一个包。文件名不需要与包名一致。包名的约定是使用小写字符。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/13/scala-learn2/">scala 类和对象</a></h2><div class="post-meta">2015-04-13</div><div class="post-content"><h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在 scala 当中的类与 java 当中的很类似：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/13/c-learn6/">c 指针与数组下</a></h2><div class="post-meta">2015-04-13</div><div class="post-content"><h4 id="指针数组以及指向指针的指针"><a href="#指针数组以及指向指针的指针" class="headerlink" title="指针数组以及指向指针的指针"></a>指针数组以及指向指针的指针</h4><p>指针数组是由指针组成的数组。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/13/go-learn2/">go 语言函数学习</a></h2><div class="post-meta">2015-04-13</div><div class="post-content"><p>有两个简单的函数例子：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/10/scala-learn1/">scala 基础学习</a></h2><div class="post-meta">2015-04-10</div><div class="post-content"><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>Scala 有两种变量：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/10/c-learn5/">c 指针与数组上</a></h2><div class="post-meta">2015-04-10</div><div class="post-content"><h4 id="指针与地址"><a href="#指针与地址" class="headerlink" title="指针与地址"></a>指针与地址</h4><p>一元运算符 &amp; 可用于取一个对象的地址</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/09/go-learn1/">go 语言学习入门1</a></h2><div class="post-meta">2015-04-09</div><div class="post-content"><p>最简单的 hello world 代码：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/08/vim-begin/">打造舒服的 vim 环境</a></h2><div class="post-meta">2015-04-08</div><div class="post-content"><p>最近一直准备换 vim 进行一些脚本的开发工作，例如 lua、shell 之类的，也顺便学习下 vim，下面的列表是收集的比较好的 vim 教程吧，等下次找的方便也比较方便</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/08/c-learn4/">c 函数学习下</a></h2><div class="post-meta">2015-04-08</div><div class="post-content"><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>用 static 声明限定外部变量与函数，可以将其后声明的对象的作用域限定为被编译源文件的剩余部分。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/04/02/jdk-list/">jdk 中的 List 分析</a></h2><div class="post-meta">2015-04-02</div><div class="post-content"><h3 id="AbstractCollection"><a href="#AbstractCollection" class="headerlink" title="AbstractCollection"></a>AbstractCollection</h3><p>此类提供 Collection 接口的骨干实现，以最大限度地减少了实现此接口所需的工作。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/23/guava-ComparisonChain-source/">ComparisonChain 源码学习</a></h2><div class="post-meta">2015-03-23</div><div class="post-content"><p>ComparisonChain 类用来简化 compare 操作的的工具类。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/19/guava-CharMatcher-source/">CharMatcher 源码学习</a></h2><div class="post-meta">2015-03-19</div><div class="post-content"><p>CharMatcher 是一个抽象类，里面唯一的抽象方法是 matches 方法：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/19/Pragmatic-Programmer-1/">程序员修炼之道之注重实效</a></h2><div class="post-meta">2015-03-19</div><div class="post-content"><h3 id="注重实效的哲学"><a href="#注重实效的哲学" class="headerlink" title="注重实效的哲学"></a>注重实效的哲学</h3><p>在解决问题的时候，我们应该越出直接的问题去思考，总是设法把问题放在更大的语境中，总是设法注意更大的图景，这样我们才能做出明智的妥协和有见识的决策。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/17/guava-strings-source/">Strings 源码学习</a></h2><div class="post-meta">2015-03-17</div><div class="post-content"><p>首先看 3 个处理空字符串的方法：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/16/guava-splitter-source/">Splitter 源码学习</a></h2><div class="post-meta">2015-03-16</div><div class="post-content"><p>Splitter 类有四个成员变量：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/13/guava-joiner-source/">Joiner 源码学习</a></h2><div class="post-meta">2015-03-13</div><div class="post-content"><p>首先看如何创建 Joiner 对象，Joiner 的构造方法是私有的，只能通过静态方法来创建 Joiner 对象，并且 Joiner 是一个不可变类。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/03/02/write-to-design1/">页面设计四大基本原则</a></h2><div class="post-meta">2015-03-02</div><div class="post-content"><h3 id="设计的四大基本原则"><a href="#设计的四大基本原则" class="headerlink" title="设计的四大基本原则"></a>设计的四大基本原则</h3><ul></div></div><div class="post"><h2 class="post-title"><a href="/2015/02/09/sed-learn2/">sed 简单入门2</a></h2><div class="post-meta">2015-02-09</div><div class="post-content"><h3 id="基本-sed-命令"><a href="#基本-sed-命令" class="headerlink" title="基本 sed 命令"></a>基本 sed 命令</h3><p>几个常用的命令：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/02/05/awk-learn2/">awk 内置表达式</a></h2><div class="post-meta">2015-02-05</div><div class="post-content"><h3 id="关系操作符和布尔表达式"><a href="#关系操作符和布尔表达式" class="headerlink" title="关系操作符和布尔表达式"></a>关系操作符和布尔表达式</h3><p>关系操作符如下表：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/29/sed-learn1/">sed 简单入门</a></h2><div class="post-meta">2015-01-29</div><div class="post-content"><h3 id="基本-sed-使用"><a href="#基本-sed-使用" class="headerlink" title="基本 sed 使用"></a>基本 sed 使用</h3><p>调用 sed 有两种方式：在命令行上或者执行文件。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/29/awk-learn1/">awk 简单入门</a></h2><div class="post-meta">2015-01-29</div><div class="post-content"><p>awk 入门的 hello world 如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/28/oop-solid/">面向对象设计原则</a></h2><div class="post-meta">2015-01-28</div><div class="post-content"><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>遵循开闭原则设计出的模块具有两个主要特征：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/27/j2ee-view-learn1/">j2ee 表现层学习1</a></h2><div class="post-meta">2015-01-27</div><div class="post-content"><h3 id="表现层设计与不佳实践"><a href="#表现层设计与不佳实践" class="headerlink" title="表现层设计与不佳实践"></a>表现层设计与不佳实践</h3><p><strong>会话管理</strong></p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/26/http-learn1/">http 简单入门</a></h2><div class="post-meta">2015-01-26</div><div class="post-content"><h3 id="媒体类型"><a href="#媒体类型" class="headerlink" title="媒体类型"></a>媒体类型</h3><p>因特网上有数千种不同的数据类型, HTTP 仔细地给每种要通过 Web 传输的对象都打上了名为 MIME 类型(MIME type)的数据格式标签。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/19/jdbc-learn4/">Jdbc事务隔离级别和ACID特性</a></h2><div class="post-meta">2015-01-19</div><div class="post-content"><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><h4 id="更新遗失-Lost-update"><a href="#更新遗失-Lost-update" class="headerlink" title="更新遗失(Lost update)"></a>更新遗失(Lost update)</h4><p>两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/19/jdbc-learn3/">JDBC 之使用</a></h2><div class="post-meta">2015-01-19</div><div class="post-content"><h3 id="创建一个获取-Connection-对象和关闭资源的工具类"><a href="#创建一个获取-Connection-对象和关闭资源的工具类" class="headerlink" title="创建一个获取 Connection 对象和关闭资源的工具类"></a>创建一个获取 Connection 对象和关闭资源的工具类</h3><p>在对数据库进行 CRUD 操作的时候，每一个操作都需要获取 Connection 对象，所以我们就可以把获取 Connection 对象的过程抽离到一个工具类当中，下面是具体代码。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/19/java-ognl1/">Java-OGNL 入门</a></h2><div class="post-meta">2015-01-19</div><div class="post-content"><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/17/jdbc-learn1/">Jdbc入门</a></h2><div class="post-meta">2015-01-17</div><div class="post-content"><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/17/jdbc-learn2/">Jdbc连接数据库</a></h2><div class="post-meta">2015-01-17</div><div class="post-content"><p>要取得数据库连接，必须有几个操作：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/14/effectivejava-learn4/">effective-java类和接口2</a></h2><div class="post-meta">2015-01-14</div><div class="post-content"><h4 id="接口优于抽象类"><a href="#接口优于抽象类" class="headerlink" title="接口优于抽象类"></a>接口优于抽象类</h4><p>现有的类可以很容易被更新，以实现新的接口。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/14/java-puzzlers-chapter5/">Java 解惑 -- 类谜题</a></h2><div class="post-meta">2015-01-14</div><div class="post-content"><h4 id="混淆的构造器"><a href="#混淆的构造器" class="headerlink" title="混淆的构造器"></a>混淆的构造器</h4><p>看如下代码会输出什么：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/13/redis-learn4/">redis集合和有序集合类型</a></h2><div class="post-meta">2015-01-13</div><div class="post-content"><h4 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h4><p>集合中的每一个元素都不同，并且没有顺序。一个集合类型键可以存储最多 2 的 32 次幂 - 1 个字符串。集合类型内部是使用散列表实现的。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/12/effectivejava-learn3/">effective-java类和接口1</a></h2><div class="post-meta">2015-01-12</div><div class="post-content"><h4 id="使类和成员的可访问性最小化"><a href="#使类和成员的可访问性最小化" class="headerlink" title="使类和成员的可访问性最小化"></a>使类和成员的可访问性最小化</h4><p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰的隔离出来。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/09/linux-shell-learn5/">shell 处理文件描述符</a></h2><div class="post-meta">2015-01-09</div><div class="post-content"><h4 id="标准文件描述符"><a href="#标准文件描述符" class="headerlink" title="标准文件描述符"></a>标准文件描述符</h4><p>Linux 用文件描述符来标识每一个文件对象。文件描述符是一个非负整数，可以唯一地标识回话中打开的文件。bash shell 保留了 3 个文件描述符。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/08/java-exception/">Java异常</a></h2><div class="post-meta">2015-01-08</div><div class="post-content"><p>异常的分类如下图：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/07/redis-learn3/">redis列表类型</a></h2><div class="post-meta">2015-01-07</div><div class="post-content"><h4 id="列表类型"><a href="#列表类型" class="headerlink" title="列表类型"></a>列表类型</h4><p>列表类型 (list) 可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素，或者获得列表的某个片段。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/07/java-puzzlers-chapter4/">Java 解惑 -- 异常谜题</a></h2><div class="post-meta">2015-01-07</div><div class="post-content"><h4 id="异常返回"><a href="#异常返回" class="headerlink" title="异常返回"></a>异常返回</h4><p>看下面这段代码：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/06/redis-learn2/">redis散列类型</a></h2><div class="post-meta">2015-01-06</div><div class="post-content"><h4 id="散列类型"><a href="#散列类型" class="headerlink" title="散列类型"></a>散列类型</h4><p>散列类型不能嵌套其他的数据类型，其他的数据类型也不支持数据类型嵌套。</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/06/java-puzzlers-chapter2-3/">Java 解惑 -- 字符串、循环谜题</a></h2><div class="post-meta">2015-01-06</div><div class="post-content"><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><p>看下面程序会打印出什么：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/05/redis-learn1/">redis字符串学习</a></h2><div class="post-meta">2015-01-05</div><div class="post-content"><h4 id="入门热身"><a href="#入门热身" class="headerlink" title="入门热身"></a>入门热身</h4><p>获取符合规则的键名列表：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/05/effectivejava-learn2/">effective-java对象通用方法</a></h2><div class="post-meta">2015-01-05</div><div class="post-content"><h4 id="覆盖-equals-方法"><a href="#覆盖-equals-方法" class="headerlink" title="覆盖 equals 方法"></a>覆盖 equals 方法</h4><p>如果要重写 equals 方法，需要遵守下面几条规定：</p></div></div><div class="post"><h2 class="post-title"><a href="/2015/01/05/shift-operators/">移位运算</a></h2><div class="post-meta">2015-01-05</div><div class="post-content"><p>移位运算符就是在二进制的基础上对数字进行平移。按照平移的方向和填充数字的规则分为三种：<code>&lt;&lt;(左移)</code>、<code>&gt;&gt;(带符号右移)</code> 和 <code>&gt;&gt;&gt;(无符号右移)</code>。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/30/git-learn5/">git偏好配置</a></h2><div class="post-meta">2014-12-30</div><div class="post-content"><h4 id="配置-Git"><a href="#配置-Git" class="headerlink" title="配置 Git"></a>配置 Git</h4><p>使用 git 的第一件事情就是配置名字和邮箱地址：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/30/jvm-gc/">Jvm垃圾收集算法</a></h2><div class="post-meta">2014-12-30</div><div class="post-content"><p>在进行<a href="http://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8" target="_blank" rel="noopener">垃圾回收</a>的时候，我们需要完成三件事情。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/29/vim-learn3/">vim 命令行模式1</a></h2><div class="post-meta">2014-12-29</div><div class="post-content"><p>在按下 ： 键时，vim 会切换到命令行模式。在任意时刻，我们都可以按 Esc 键从命令行模式切换回普通模式。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/29/git-learn4/">git 分支学习2</a></h2><div class="post-meta">2014-12-29</div><div class="post-content"><h4 id="冲突的合并"><a href="#冲突的合并" class="headerlink" title="冲突的合并"></a>冲突的合并</h4><p>如果两个分支的合并过程当中存在冲突，会出现下面结果:</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/29/effectivejava-learn1/">effective-java创建和销毁对象</a></h2><div class="post-meta">2014-12-29</div><div class="post-content"><h4 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h4><p>静态工厂方法与构造器不同的第一大优势在于，它们有名称。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/25/java-puzzlers-chapter1/">Java 解惑 -- 表达式谜题</a></h2><div class="post-meta">2014-12-25</div><div class="post-content"><h4 id="奇数性"><a href="#奇数性" class="headerlink" title="奇数性"></a>奇数性</h4><p>在判断一个整数是否为奇数的时候不要用余数为1来判断，因为会有负数的情况，应该用余数不为0来判断。如果需要更加的性能，可以使用如下的方式：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/25/java-autoboxing-unboxing/">Java 自动装箱和拆箱</a></h2><div class="post-meta">2014-12-25</div><div class="post-content"><p>装箱就是 java 编译器自动把基本类型转换成对应的封装类型。例如，转换 int 到 Interger，double 到 Double 等等。转换的方向相反的话就是拆箱。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/24/symbolic-number/">原码、反码和补码</a></h2><div class="post-meta">2014-12-24</div><div class="post-content"><p>计算机中的符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/22/git-learn3/">git 分支学习1</a></h2><div class="post-meta">2014-12-22</div><div class="post-content"><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><p>Git 会使用 master 作为分支的没人名字。创建分支使用下面的命令，但是它创建完新的分支后不会切换到新的分支上去。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/19/git-learn2/">git 基础学习2</a></h2><div class="post-meta">2014-12-19</div><div class="post-content"><h4 id="查看已暂存和未暂存更新"><a href="#查看已暂存和未暂存更新" class="headerlink" title="查看已暂存和未暂存更新"></a>查看已暂存和未暂存更新</h4><p>如果要看尚未暂存的文件更新了哪些部分，可以使用不加参数的 diff 命令：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/19/base64-encoding/">base64 编码原理</a></h2><div class="post-meta">2014-12-19</div><div class="post-content"><p>Base 64 Encoding 的编码原理是将每三个字节（byte）转换为四个字符，每个字符占 6 bit。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/18/vim-learn2/">vim 插入模式和可视模式</a></h2><div class="post-meta">2014-12-18</div><div class="post-content"><h4 id="插入模式中更正错误"><a href="#插入模式中更正错误" class="headerlink" title="插入模式中更正错误"></a>插入模式中更正错误</h4><p>在插入模式的时候，删除错误字符一般会用到退格键。另外，我们也可以使用一些组合键：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/18/class-structure/">Java Class 文件结构</a></h2><div class="post-meta">2014-12-18</div><div class="post-content"><h4 id="Class-类文件的结构"><a href="#Class-类文件的结构" class="headerlink" title="Class 类文件的结构"></a>Class 类文件的结构</h4><p>Class 文件是一组以8位字节位基础单元的二进制流，各个数据项目严格按照顺序紧凑地排列在 Class 文件之中，之间没有任何分隔符。当遇到需要占用8位字节以上空间的数据项，则会按照高位在前的方式分割成若干个8位字节进行存储。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/16/jvm-classloader/">Java 类加载器</a></h2><div class="post-meta">2014-12-16</div><div class="post-content"><h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。简单的说，如果要比较两个类是否相等，必须这个两个类是由同一个类加载器加载的前提之下才有意义。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/15/jvm-data-area-lifecycle/">JVM 运行时数据区和类加载机制</a></h2><div class="post-meta">2014-12-15</div><div class="post-content"><h3 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h3><p><img src="https://renchunxiao.com/public/images/jvm-data-area.jpg" alt="JVM 运行时数据区图"></p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/12/java-concurrenct-learn2/">Java并发学习2</a></h2><div class="post-meta">2014-12-12</div><div class="post-content"><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>死锁描述的情况是两个或多个线程被阻塞永远等待对方。下面是一个例子。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/11/simplify-code-logic/">简化代码逻辑</a></h2><div class="post-meta">2014-12-11</div><div class="post-content"><h4 id="拆分超长的表达式"><a href="#拆分超长的表达式" class="headerlink" title="拆分超长的表达式"></a>拆分超长的表达式</h4><p>如果代码块特别大的话会非常难以阅读，经常用的方法就是把超长表达式拆分成容易理解的小块。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/11/java-concurrenct-learn1/">Java并发学习1</a></h2><div class="post-meta">2014-12-11</div><div class="post-content"><h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><p>在并发编程中，有两个基本概念：线程和进程。在 java 当中，并发主要关注线程，当然进程也很重要。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/09/javac1/">jdk 工具 javac 命令1</a></h2><div class="post-meta">2014-12-09</div><div class="post-content"><p>javac 命令，javac 命令是 Java programming language compiler 的简写。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/05/bash-short-key/">bash 快捷键</a></h2><div class="post-meta">2014-12-05</div><div class="post-content"><p>介绍一些 bash 常用的快捷键，zsh 的快捷键基本上适用</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/04/how-to-write-comment/">如何写注释</a></h2><div class="post-meta">2014-12-04</div><div class="post-content"><h4 id="代码审美"><a href="#代码审美" class="headerlink" title="代码审美"></a>代码审美</h4><ul></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/03/guava-working-with-file/">Guava操作文件工具类</a></h2><div class="post-meta">2014-12-03</div><div class="post-content"><p>读写文件是一个很核心的编程任务。java 提供了一个丰富和健壮的库来进行 I/O 操作，但是执行一些基本操作非常繁琐。Guava 提供了一些简单的工具类。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/01/c-learn3/">c 函数学习上</a></h2><div class="post-meta">2014-12-01</div><div class="post-content"><h4 id="函数的基本知识"><a href="#函数的基本知识" class="headerlink" title="函数的基本知识"></a>函数的基本知识</h4><p>函数定义中的各构成部分都可以省略。最简单的函数如下所示:</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/12/01/how-to-choice-name/">代码中如何选取名字</a></h2><div class="post-meta">2014-12-01</div><div class="post-content"><p>我们在编写代码的时候有同一个主题思想，<strong>代码应当易于理解</strong>。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/26/c-learn2/">c语言控制流</a></h2><div class="post-meta">2014-11-26</div><div class="post-content"><h4 id="if-else-语句"><a href="#if-else-语句" class="headerlink" title="if-else 语句"></a>if-else 语句</h4><p>语法如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/26/guava-cache/">Guava缓存</a></h2><div class="post-meta">2014-11-26</div><div class="post-content"><h4 id="MapMaker"><a href="#MapMaker" class="headerlink" title="MapMaker"></a>MapMaker</h4><p>MapMaker 使用流 api，允许我们快速创建 ConcurrentHashMap，让我们看下面的例子：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/24/guava-collections/">Guava提供的集合</a></h2><div class="post-meta">2014-11-24</div><div class="post-content"><h4 id="使用-FluentIterable-类"><a href="#使用-FluentIterable-类" class="headerlink" title="使用 FluentIterable 类"></a>使用 FluentIterable 类</h4><p>FluentIterable 类提供一组强大的接口来操作 Iterable 实例，通过一种流畅的编程方式。这种流畅的编程方式允许我们使用链式调用，使我们的代码更加可读。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/18/guava-functional-programming/">使用Guava进行函数编程</a></h2><div class="post-meta">2014-11-18</div><div class="post-content"><h4 id="使用-Function-接口"><a href="#使用-Function-接口" class="headerlink" title="使用 Function 接口"></a>使用 Function 接口</h4><p>函数式编程强调使用函数，以实现其目标与不断变化的状态。这与大多数开发者熟悉的改变状态的编程方式形成对比。Function 接口让我们在 java 代码当中引入函数式编程成为可能。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/17/guava-basic-utilties/">Guava基本工具类</a></h2><div class="post-meta">2014-11-17</div><div class="post-content"><h4 id="使用-Joiner-类"><a href="#使用-Joiner-类" class="headerlink" title="使用 Joiner 类"></a>使用 Joiner 类</h4><p>将任意字符串通过分隔符进行连接到一起是大多程序员经常做的事情。他们经常使用 array，list，iterable 并且循环变量将每一个临时变量添加到 StringBuilder 当中去，并且中间添加分隔符。这些笨重的处理方式如下:</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/16/c-leran1/">c语言类型运算符表达式</a></h2><div class="post-meta">2014-11-16</div><div class="post-content"><h4 id="c语言入门"><a href="#c语言入门" class="headerlink" title="c语言入门"></a>c语言入门</h4><p>最简单的c代码</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/15/js-learn1/">js词法结构和类型</a></h2><div class="post-meta">2014-11-15</div><div class="post-content"><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>js程序是用Unicode字符集编写的。并且js的区分大小写的语言。需要注意的是html并不区分大小写。例如，在html中设置时间处理onclick属性可以写成onClick，但是在js当中只可以写成onclick。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/07/linux-shell-learn3/">shell当中的循环</a></h2><div class="post-meta">2014-11-07</div><div class="post-content"><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for循环的基本格式如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/06/linux-shell-learn2/">shell当中的if-else语句</a></h2><div class="post-meta">2014-11-06</div><div class="post-content"><h4 id="if-then语句"><a href="#if-then语句" class="headerlink" title="if-then语句"></a>if-then语句</h4><p>if-then语句的格式如下：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/04/linux-shell-leran1/">构建基本shell脚本</a></h2><div class="post-meta">2014-11-04</div><div class="post-content"><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>shell维护着一组环境变量，用来记录系统特定的信息。如，系统名称，用户UID等。使用set命令查看完整的环境变量。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/11/03/java-arraylist/">Java中ArrayList源码分析</a></h2><div class="post-meta">2014-11-03</div><div class="post-content"><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/31/java-jcf1/">Java集合框架整理1</a></h2><div class="post-meta">2014-10-31</div><div class="post-content"><h4 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h4><p>JCF是Java CollectionsFramework的缩写，是Java提供的对集合进行定义、操作、管理的一组接口和类的体系结构。它主要包括两种主要类型Collection和Map，并且提供了对应的Collection和Map接口。JCF框架的核心接口如下图所示：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/30/eclipse-shortkey/">eclipse快捷键</a></h2><div class="post-meta">2014-10-30</div><div class="post-content"><h4 id="删除："><a href="#删除：" class="headerlink" title="删除："></a>删除：</h4><p>Delete 删除后一个字符</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/29/sort-learn1/">冒泡排序&amp;选择排序&amp;插入排序</a></h2><div class="post-meta">2014-10-29</div><div class="post-content"><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/27/jsonp/">了解jsonp</a></h2><div class="post-meta">2014-10-27</div><div class="post-content"><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/21/html-learn1/">html创建结构化文档</a></h2><div class="post-meta">2014-10-21</div><div class="post-content"><h4 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h4><p><code>&lt;html&gt;</code>的直接子元素只有，<code>&lt;head&gt;</code>和<code>&lt;body&gt;</code>两个。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/20/java-http/">Java原生发起Http请求</a></h2><div class="post-meta">2014-10-20</div><div class="post-content"><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>项目中经常使用java进行http的访问，一般都使用apache的http client库来进行http请求。这次主要学习下使用jdk原生代码来进行http请求，分别学习get和post请求。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/18/java-enum/">Java枚举</a></h2><div class="post-meta">2014-10-18</div><div class="post-content"><h4 id="基本enum特性"><a href="#基本enum特性" class="headerlink" title="基本enum特性"></a>基本enum特性</h4><p>当创建一个enum的时候，编译器会生成一个相关的类，这个类继承于java.lang.Enum。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/16/programming-practice1/">程序设计风格</a></h2><div class="post-meta">2014-10-16</div><div class="post-content"><h3 id="名字"><a href="#名字" class="headerlink" title="名字"></a>名字</h3><p>什么是名字？一个变量或函数的名字标识这个对象，带着说明其用途的一些信息。一个名<br>字应该是非形式的、简练的、容易记忆的。许多信息来自上下文和作用范围(作用域)。一个变量的作用域越大，它的名字所携带的信息就应该越多。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/13/java-inner-class/">Java内部类</a></h2><div class="post-meta">2014-10-13</div><div class="post-content"><h4 id="为什么Java支持嵌套类"><a href="#为什么Java支持嵌套类" class="headerlink" title="为什么Java支持嵌套类"></a>为什么Java支持嵌套类</h4><p>Java支持嵌套类有两个好处：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/13/bootstrap-learn1/">Bootstrap基础学习1</a></h2><div class="post-meta">2014-10-13</div><div class="post-content"><h4 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h4><p>Bootstrap 需要为页面内容和栅格系统包裹一个 <code>.container</code> 容器。我们提供了两个这样的类。注意，由于 padding 等属性的原因，这两种容器类不能互相嵌套。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/10/java-access-modifier/">Java访问修饰符</a></h2><div class="post-meta">2014-10-10</div><div class="post-content"><h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>java提供了四种访问修饰符，从大到小的权限依次为：public、protected、包访问权限（没有关键词）、private。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/10/bit-operation/">位运算</a></h2><div class="post-meta">2014-10-10</div><div class="post-content"><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><blockquote></div></div><div class="post"><h2 class="post-title"><a href="/2014/10/08/lua-learn3/">lua学习3</a></h2><div class="post-meta">2014-10-08</div><div class="post-content"><h4 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h4><p>Lua中的函数可以接受不同数量的实参。例如：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/09/29/lua-learn2/">lua学习2</a></h2><div class="post-meta">2014-09-29</div><div class="post-content"><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>Lua支持多重赋值，就是可以将多个值同时赋值给多个变量。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/09/25/regular-expression-leran1/">正则表达式</a></h2><div class="post-meta">2014-09-25</div><div class="post-content"><h4 id="匹配单个字符"><a href="#匹配单个字符" class="headerlink" title="匹配单个字符"></a>匹配单个字符</h4><ul></div></div><div class="post"><h2 class="post-title"><a href="/2014/09/24/lua-learn1/">lua学习1</a></h2><div class="post-meta">2014-09-24</div><div class="post-content"><h4 id="类型与值"><a href="#类型与值" class="headerlink" title="类型与值"></a>类型与值</h4><p>Lua是一种动态语言，没有定义类型的语法，每个值都携带了自身的类型信息。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/09/22/vim-learn1/">vim学习1</a></h2><div class="post-meta">2014-09-22</div><div class="post-content"><h3 id="vim学习1"><a href="#vim学习1" class="headerlink" title="vim学习1"></a>vim学习1</h3><h4 id="vim的插入模式"><a href="#vim的插入模式" class="headerlink" title="vim的插入模式"></a>vim的插入模式</h4><table></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/23/linux-important-command/">linux重要命令</a></h2><div class="post-meta">2014-08-23</div><div class="post-content"><h3 id="linux重要命令"><a href="#linux重要命令" class="headerlink" title="linux重要命令"></a>linux重要命令</h3><h4 id="grep命令："><a href="#grep命令：" class="headerlink" title="grep命令："></a>grep命令：</h4><p>语法:grep [参数] pattern [文件名]</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/17/j2ee-servlet-mapping/">映射请求到servlet</a></h2><div class="post-meta">2014-08-17</div><div class="post-content"><h3 id="servlet规范当中对映射请求的描述："><a href="#servlet规范当中对映射请求的描述：" class="headerlink" title="servlet规范当中对映射请求的描述："></a>servlet规范当中对映射请求的描述：</h3><p>在收到客户端请求时，web 容器确定转发到哪一个Web应用。选择的Web应用必须具有最长的上下文路径匹配请求URL的开始。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/17/git-learn1/">git 基础学习</a></h2><div class="post-meta">2014-08-17</div><div class="post-content"><h3 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h3><p>在当前目录初始化,使用git init命令,初始化后当前目录下会出现一个名为.git的目录。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/16/Linux-filemanage/">linux 文件管理</a></h2><div class="post-meta">2014-08-16</div><div class="post-content"><h3 id="Linux文件管理"><a href="#Linux文件管理" class="headerlink" title="Linux文件管理"></a>Linux文件管理</h3><p>在Linux系统当中，所有文件和目录都存放在根目录下，即/下。FHS(文件系统层次标准)定义了在根目录下的主要目录以及每个目录存放什么文件。如下表：</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/14/Linux-usermanage/">linux 用户管理</a></h2><div class="post-meta">2014-08-14</div><div class="post-content"><h3 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h3><p>GID,UID。不同的用户有不同的UID(user id)，不同的组有不用的GID(group id)。</p></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/11/Linux-Shell-1chapter/">linux shell 小试牛刀</a></h2><div class="post-meta">2014-08-11</div><div class="post-content"><h4 id="第一章-小试牛刀"><a href="#第一章-小试牛刀" class="headerlink" title="第一章 小试牛刀"></a>第一章 小试牛刀</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><ul></div></div><div class="post"><h2 class="post-title"><a href="/2014/08/05/TheArtofReadableCode-7chapter/">把控制流变得易读</a></h2><div class="post-meta">2014-08-05</div><div class="post-content"><h2 id="第七章-把控制流变得易读"><a href="#第七章-把控制流变得易读" class="headerlink" title="第七章 把控制流变得易读"></a>第七章 把控制流变得易读</h2><h3 id="1-条件语句中的参数的顺序"><a href="#1-条件语句中的参数的顺序" class="headerlink" title="1.条件语句中的参数的顺序"></a>1.条件语句中的参数的顺序</h3><p>比较的左侧放置倾向于变化的，比较的右侧是放置不变化的</p></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" id="search" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://renchunxiao.com"/></form></div><div class="widget"><div class="widget-title"> 分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Bootstrap学习/">Bootstrap学习</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Elasticsearch/">Elasticsearch</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java解惑/">Java解惑</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/cache/">cache</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/eclipse/">eclipse</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/effective-java/">effective-java</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/go/">go</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/guava/">guava</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/html/">html</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/http/">http</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/j2ee/">j2ee</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java-ognl/">java-ognl</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/javaNIO/">javaNIO</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java基础/">java基础</a><span class="category-list-count">31</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jdbc/">jdbc</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jms/">jms</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/js基础/">js基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/junit/">junit</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">13</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/log/">log</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/lua/">lua</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/maven/">maven</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mybatis/">mybatis</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/mysql/">mysql</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/scala/">scala</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/tcp-ip/">tcp/ip</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vim/">vim</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/websocket/">websocket</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/代码优化/">代码优化</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/折腾/">折腾</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库连接池/">数据库连接池</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/正则表达式/">正则表达式</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/理解计算机/">理解计算机</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/程序员修炼/">程序员修炼</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/重构/">重构</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/页面设计/">页面设计</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"> 标签</div><div class="tagcloud"><a href="/tags/面向对象-设计原则/" style="font-size: 12px;">面向对象 设计原则</a> <a href="/tags/笔记-代码优化/" style="font-size: 13.5px;">笔记 代码优化</a> <a href="/tags/linux/" style="font-size: 12.5px;">linux</a> <a href="/tags/linux-基础-笔记/" style="font-size: 12px;">linux 基础 笔记</a> <a href="/tags/git-学习笔记/" style="font-size: 14px;">git 学习笔记</a> <a href="/tags/j2ee-sevlet/" style="font-size: 12px;">j2ee sevlet</a> <a href="/tags/vim-学习笔记/" style="font-size: 13.5px;">vim 学习笔记</a> <a href="/tags/lua/" style="font-size: 13.5px;">lua</a> <a href="/tags/正则表达式/" style="font-size: 12px;">正则表达式</a> <a href="/tags/笔记-位运算/" style="font-size: 12.5px;">笔记 位运算</a> <a href="/tags/笔记/" style="font-size: 17.5px;">笔记</a> <a href="/tags/笔记-前端/" style="font-size: 12px;">笔记 前端</a> <a href="/tags/笔记-代码优化-程序设计实践笔记/" style="font-size: 12px;">笔记 代码优化 程序设计实践笔记</a> <a href="/tags/html/" style="font-size: 12px;">html</a> <a href="/tags/json-js-jsonp/" style="font-size: 12px;">json js jsonp</a> <a href="/tags/算法/" style="font-size: 12px;">算法</a> <a href="/tags/eclipse/" style="font-size: 12px;">eclipse</a> <a href="/tags/js/" style="font-size: 12px;">js</a> <a href="/tags/笔记-c/" style="font-size: 15px;">笔记 c</a> <a href="/tags/笔记-java/" style="font-size: 18px;">笔记 java</a> <a href="/tags/编码-base64/" style="font-size: 12px;">编码 base64</a> <a href="/tags/redis/" style="font-size: 13.5px;">redis</a> <a href="/tags/j2ee-jdbc/" style="font-size: 13.5px;">j2ee jdbc</a> <a href="/tags/java-ognl/" style="font-size: 12px;">java ognl</a> <a href="/tags/笔记-http/" style="font-size: 12.5px;">笔记 http</a> <a href="/tags/笔记-j2ee/" style="font-size: 12px;">笔记 j2ee</a> <a href="/tags/linux-shell/" style="font-size: 14.5px;">linux shell</a> <a href="/tags/linux-awk/" style="font-size: 12.5px;">linux awk</a> <a href="/tags/linux-sed/" style="font-size: 12.5px;">linux sed</a> <a href="/tags/go-学习笔记/" style="font-size: 13px;">go 学习笔记</a> <a href="/tags/笔记-scala/" style="font-size: 16.5px;">笔记 scala</a> <a href="/tags/mysql/" style="font-size: 12.5px;">mysql</a> <a href="/tags/lua-string/" style="font-size: 12px;">lua, string</a> <a href="/tags/lua-table/" style="font-size: 12px;">lua,table</a> <a href="/tags/java-junit/" style="font-size: 13px;">java, junit</a> <a href="/tags/java-jms/" style="font-size: 12.5px;">java, jms</a> <a href="/tags/java-maven/" style="font-size: 13px;">java, maven</a> <a href="/tags/java-cache/" style="font-size: 15.5px;">java, cache</a> <a href="/tags/java-log/" style="font-size: 12.5px;">java, log</a> <a href="/tags/java/" style="font-size: 16px;">java</a> <a href="/tags/锁/" style="font-size: 12px;">锁</a> <a href="/tags/笔记-java/" style="font-size: 17px;">笔记, java</a> <a href="/tags/lua/" style="font-size: 12px;">lua,</a> <a href="/tags/java-连接池/" style="font-size: 12.5px;">java, 连接池</a> <a href="/tags/笔记-ES/" style="font-size: 14.5px;">笔记, ES</a> <a href="/tags/笔记-Android/" style="font-size: 12.5px;">笔记, Android</a> <a href="/tags/笔记，docker/" style="font-size: 12px;">笔记，docker</a> <a href="/tags/笔记-mybatis/" style="font-size: 16px;">笔记, mybatis</a> <a href="/tags/笔记，redis/" style="font-size: 12px;">笔记，redis</a> <a href="/tags/笔记-websocket/" style="font-size: 12px;">笔记, websocket</a> <a href="/tags/笔记-tcp-ip协议/" style="font-size: 13px;">笔记, tcp/ip协议</a> <a href="/tags/笔记-数据结构/" style="font-size: 12.5px;">笔记, 数据结构</a></div></div><div class="widget"><div class="widget-title"> 最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/11/11/timestamp/">深入理解程序中的时间属性</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/cms-gc/">深入学习 CMS GC</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/10/09/linkedlist-algorithm1/">LinkedList 简单算法题解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/28/java-thread-safe/">java 线程安全性</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/21/java-stack/">java 实现 stack</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/javaio-tips/">Java IO 概念理清</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/09/09/java-list-iterator/">jdk 中的 List 的迭代方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/16/tree-inTraverse/">二叉树的中序遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/08/15/tree-PreTraverse/">二叉树的先序遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/29/elasticsearch-mapping/">Elasticsearch Mapping 学习</a></li></ul></div><div class="widget"><div class="widget-title"> 友情链接</div><ul class="links-list"><li class="links-list-item"><a href="http://www.example.com" title="标题" target="_blank">标题</a></li></ul></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">任春晓的博客.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> Theme<a target="_blank" href="https://github.com/7ye/maupassant-hexo"> Maupassant.</a></div><a id="back_to_top" href="javascript:void(0)" class="back_to_top"><span>△</span></a><script type="text/javascript" src="/js/totop.js?v=0.0.1"></script><link rel="stylesheet" href="/css/jquery.fancybox.css"><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.1"></script><script>function auto_code_fit(){
  if($(".highlight").length != 0){
    var pc_width = $(".post-content").width();
    $(".highlight .code").find("pre").width((pc_width-70)+"px");
  }
}
window.onresize = function(){
  auto_code_fit();
}
auto_code_fit();</script></div></body>